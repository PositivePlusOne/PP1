// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'notification_action.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$NotificationAction {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() test,
    required TResult Function() connectionRequestAccepted,
    required TResult Function() connectionRequestRejected,
    required TResult Function() connectionRequestSent,
    required TResult Function() connectionRequestReceived,
    required TResult Function() relationshipUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? test,
    TResult? Function()? connectionRequestAccepted,
    TResult? Function()? connectionRequestRejected,
    TResult? Function()? connectionRequestSent,
    TResult? Function()? connectionRequestReceived,
    TResult? Function()? relationshipUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? test,
    TResult Function()? connectionRequestAccepted,
    TResult Function()? connectionRequestRejected,
    TResult Function()? connectionRequestSent,
    TResult Function()? connectionRequestReceived,
    TResult Function()? relationshipUpdated,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(None value) none,
    required TResult Function(Test value) test,
    required TResult Function(ConnectionRequestAccepted value)
        connectionRequestAccepted,
    required TResult Function(ConnectionRequestRejected value)
        connectionRequestRejected,
    required TResult Function(ConnectionRequestSent value)
        connectionRequestSent,
    required TResult Function(ConnectionRequestReceived value)
        connectionRequestReceived,
    required TResult Function(RelationshipUpdated value) relationshipUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(None value)? none,
    TResult? Function(Test value)? test,
    TResult? Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult? Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult? Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult? Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult? Function(RelationshipUpdated value)? relationshipUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(None value)? none,
    TResult Function(Test value)? test,
    TResult Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult Function(RelationshipUpdated value)? relationshipUpdated,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NotificationActionCopyWith<$Res> {
  factory $NotificationActionCopyWith(
          NotificationAction value, $Res Function(NotificationAction) then) =
      _$NotificationActionCopyWithImpl<$Res, NotificationAction>;
}

/// @nodoc
class _$NotificationActionCopyWithImpl<$Res, $Val extends NotificationAction>
    implements $NotificationActionCopyWith<$Res> {
  _$NotificationActionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NoneCopyWith<$Res> {
  factory _$$NoneCopyWith(_$None value, $Res Function(_$None) then) =
      __$$NoneCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoneCopyWithImpl<$Res>
    extends _$NotificationActionCopyWithImpl<$Res, _$None>
    implements _$$NoneCopyWith<$Res> {
  __$$NoneCopyWithImpl(_$None _value, $Res Function(_$None) _then)
      : super(_value, _then);
}

/// @nodoc

class _$None implements None {
  const _$None();

  @override
  String toString() {
    return 'NotificationAction.none()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$None);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() test,
    required TResult Function() connectionRequestAccepted,
    required TResult Function() connectionRequestRejected,
    required TResult Function() connectionRequestSent,
    required TResult Function() connectionRequestReceived,
    required TResult Function() relationshipUpdated,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? test,
    TResult? Function()? connectionRequestAccepted,
    TResult? Function()? connectionRequestRejected,
    TResult? Function()? connectionRequestSent,
    TResult? Function()? connectionRequestReceived,
    TResult? Function()? relationshipUpdated,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? test,
    TResult Function()? connectionRequestAccepted,
    TResult Function()? connectionRequestRejected,
    TResult Function()? connectionRequestSent,
    TResult Function()? connectionRequestReceived,
    TResult Function()? relationshipUpdated,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(None value) none,
    required TResult Function(Test value) test,
    required TResult Function(ConnectionRequestAccepted value)
        connectionRequestAccepted,
    required TResult Function(ConnectionRequestRejected value)
        connectionRequestRejected,
    required TResult Function(ConnectionRequestSent value)
        connectionRequestSent,
    required TResult Function(ConnectionRequestReceived value)
        connectionRequestReceived,
    required TResult Function(RelationshipUpdated value) relationshipUpdated,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(None value)? none,
    TResult? Function(Test value)? test,
    TResult? Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult? Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult? Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult? Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult? Function(RelationshipUpdated value)? relationshipUpdated,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(None value)? none,
    TResult Function(Test value)? test,
    TResult Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult Function(RelationshipUpdated value)? relationshipUpdated,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class None implements NotificationAction {
  const factory None() = _$None;
}

/// @nodoc
abstract class _$$TestCopyWith<$Res> {
  factory _$$TestCopyWith(_$Test value, $Res Function(_$Test) then) =
      __$$TestCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TestCopyWithImpl<$Res>
    extends _$NotificationActionCopyWithImpl<$Res, _$Test>
    implements _$$TestCopyWith<$Res> {
  __$$TestCopyWithImpl(_$Test _value, $Res Function(_$Test) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Test implements Test {
  const _$Test();

  @override
  String toString() {
    return 'NotificationAction.test()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Test);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() test,
    required TResult Function() connectionRequestAccepted,
    required TResult Function() connectionRequestRejected,
    required TResult Function() connectionRequestSent,
    required TResult Function() connectionRequestReceived,
    required TResult Function() relationshipUpdated,
  }) {
    return test();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? test,
    TResult? Function()? connectionRequestAccepted,
    TResult? Function()? connectionRequestRejected,
    TResult? Function()? connectionRequestSent,
    TResult? Function()? connectionRequestReceived,
    TResult? Function()? relationshipUpdated,
  }) {
    return test?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? test,
    TResult Function()? connectionRequestAccepted,
    TResult Function()? connectionRequestRejected,
    TResult Function()? connectionRequestSent,
    TResult Function()? connectionRequestReceived,
    TResult Function()? relationshipUpdated,
    required TResult orElse(),
  }) {
    if (test != null) {
      return test();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(None value) none,
    required TResult Function(Test value) test,
    required TResult Function(ConnectionRequestAccepted value)
        connectionRequestAccepted,
    required TResult Function(ConnectionRequestRejected value)
        connectionRequestRejected,
    required TResult Function(ConnectionRequestSent value)
        connectionRequestSent,
    required TResult Function(ConnectionRequestReceived value)
        connectionRequestReceived,
    required TResult Function(RelationshipUpdated value) relationshipUpdated,
  }) {
    return test(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(None value)? none,
    TResult? Function(Test value)? test,
    TResult? Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult? Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult? Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult? Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult? Function(RelationshipUpdated value)? relationshipUpdated,
  }) {
    return test?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(None value)? none,
    TResult Function(Test value)? test,
    TResult Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult Function(RelationshipUpdated value)? relationshipUpdated,
    required TResult orElse(),
  }) {
    if (test != null) {
      return test(this);
    }
    return orElse();
  }
}

abstract class Test implements NotificationAction {
  const factory Test() = _$Test;
}

/// @nodoc
abstract class _$$ConnectionRequestAcceptedCopyWith<$Res> {
  factory _$$ConnectionRequestAcceptedCopyWith(
          _$ConnectionRequestAccepted value,
          $Res Function(_$ConnectionRequestAccepted) then) =
      __$$ConnectionRequestAcceptedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConnectionRequestAcceptedCopyWithImpl<$Res>
    extends _$NotificationActionCopyWithImpl<$Res, _$ConnectionRequestAccepted>
    implements _$$ConnectionRequestAcceptedCopyWith<$Res> {
  __$$ConnectionRequestAcceptedCopyWithImpl(_$ConnectionRequestAccepted _value,
      $Res Function(_$ConnectionRequestAccepted) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConnectionRequestAccepted implements ConnectionRequestAccepted {
  const _$ConnectionRequestAccepted();

  @override
  String toString() {
    return 'NotificationAction.connectionRequestAccepted()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConnectionRequestAccepted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() test,
    required TResult Function() connectionRequestAccepted,
    required TResult Function() connectionRequestRejected,
    required TResult Function() connectionRequestSent,
    required TResult Function() connectionRequestReceived,
    required TResult Function() relationshipUpdated,
  }) {
    return connectionRequestAccepted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? test,
    TResult? Function()? connectionRequestAccepted,
    TResult? Function()? connectionRequestRejected,
    TResult? Function()? connectionRequestSent,
    TResult? Function()? connectionRequestReceived,
    TResult? Function()? relationshipUpdated,
  }) {
    return connectionRequestAccepted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? test,
    TResult Function()? connectionRequestAccepted,
    TResult Function()? connectionRequestRejected,
    TResult Function()? connectionRequestSent,
    TResult Function()? connectionRequestReceived,
    TResult Function()? relationshipUpdated,
    required TResult orElse(),
  }) {
    if (connectionRequestAccepted != null) {
      return connectionRequestAccepted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(None value) none,
    required TResult Function(Test value) test,
    required TResult Function(ConnectionRequestAccepted value)
        connectionRequestAccepted,
    required TResult Function(ConnectionRequestRejected value)
        connectionRequestRejected,
    required TResult Function(ConnectionRequestSent value)
        connectionRequestSent,
    required TResult Function(ConnectionRequestReceived value)
        connectionRequestReceived,
    required TResult Function(RelationshipUpdated value) relationshipUpdated,
  }) {
    return connectionRequestAccepted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(None value)? none,
    TResult? Function(Test value)? test,
    TResult? Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult? Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult? Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult? Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult? Function(RelationshipUpdated value)? relationshipUpdated,
  }) {
    return connectionRequestAccepted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(None value)? none,
    TResult Function(Test value)? test,
    TResult Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult Function(RelationshipUpdated value)? relationshipUpdated,
    required TResult orElse(),
  }) {
    if (connectionRequestAccepted != null) {
      return connectionRequestAccepted(this);
    }
    return orElse();
  }
}

abstract class ConnectionRequestAccepted implements NotificationAction {
  const factory ConnectionRequestAccepted() = _$ConnectionRequestAccepted;
}

/// @nodoc
abstract class _$$ConnectionRequestRejectedCopyWith<$Res> {
  factory _$$ConnectionRequestRejectedCopyWith(
          _$ConnectionRequestRejected value,
          $Res Function(_$ConnectionRequestRejected) then) =
      __$$ConnectionRequestRejectedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConnectionRequestRejectedCopyWithImpl<$Res>
    extends _$NotificationActionCopyWithImpl<$Res, _$ConnectionRequestRejected>
    implements _$$ConnectionRequestRejectedCopyWith<$Res> {
  __$$ConnectionRequestRejectedCopyWithImpl(_$ConnectionRequestRejected _value,
      $Res Function(_$ConnectionRequestRejected) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConnectionRequestRejected implements ConnectionRequestRejected {
  const _$ConnectionRequestRejected();

  @override
  String toString() {
    return 'NotificationAction.connectionRequestRejected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConnectionRequestRejected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() test,
    required TResult Function() connectionRequestAccepted,
    required TResult Function() connectionRequestRejected,
    required TResult Function() connectionRequestSent,
    required TResult Function() connectionRequestReceived,
    required TResult Function() relationshipUpdated,
  }) {
    return connectionRequestRejected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? test,
    TResult? Function()? connectionRequestAccepted,
    TResult? Function()? connectionRequestRejected,
    TResult? Function()? connectionRequestSent,
    TResult? Function()? connectionRequestReceived,
    TResult? Function()? relationshipUpdated,
  }) {
    return connectionRequestRejected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? test,
    TResult Function()? connectionRequestAccepted,
    TResult Function()? connectionRequestRejected,
    TResult Function()? connectionRequestSent,
    TResult Function()? connectionRequestReceived,
    TResult Function()? relationshipUpdated,
    required TResult orElse(),
  }) {
    if (connectionRequestRejected != null) {
      return connectionRequestRejected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(None value) none,
    required TResult Function(Test value) test,
    required TResult Function(ConnectionRequestAccepted value)
        connectionRequestAccepted,
    required TResult Function(ConnectionRequestRejected value)
        connectionRequestRejected,
    required TResult Function(ConnectionRequestSent value)
        connectionRequestSent,
    required TResult Function(ConnectionRequestReceived value)
        connectionRequestReceived,
    required TResult Function(RelationshipUpdated value) relationshipUpdated,
  }) {
    return connectionRequestRejected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(None value)? none,
    TResult? Function(Test value)? test,
    TResult? Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult? Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult? Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult? Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult? Function(RelationshipUpdated value)? relationshipUpdated,
  }) {
    return connectionRequestRejected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(None value)? none,
    TResult Function(Test value)? test,
    TResult Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult Function(RelationshipUpdated value)? relationshipUpdated,
    required TResult orElse(),
  }) {
    if (connectionRequestRejected != null) {
      return connectionRequestRejected(this);
    }
    return orElse();
  }
}

abstract class ConnectionRequestRejected implements NotificationAction {
  const factory ConnectionRequestRejected() = _$ConnectionRequestRejected;
}

/// @nodoc
abstract class _$$ConnectionRequestSentCopyWith<$Res> {
  factory _$$ConnectionRequestSentCopyWith(_$ConnectionRequestSent value,
          $Res Function(_$ConnectionRequestSent) then) =
      __$$ConnectionRequestSentCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConnectionRequestSentCopyWithImpl<$Res>
    extends _$NotificationActionCopyWithImpl<$Res, _$ConnectionRequestSent>
    implements _$$ConnectionRequestSentCopyWith<$Res> {
  __$$ConnectionRequestSentCopyWithImpl(_$ConnectionRequestSent _value,
      $Res Function(_$ConnectionRequestSent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConnectionRequestSent implements ConnectionRequestSent {
  const _$ConnectionRequestSent();

  @override
  String toString() {
    return 'NotificationAction.connectionRequestSent()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ConnectionRequestSent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() test,
    required TResult Function() connectionRequestAccepted,
    required TResult Function() connectionRequestRejected,
    required TResult Function() connectionRequestSent,
    required TResult Function() connectionRequestReceived,
    required TResult Function() relationshipUpdated,
  }) {
    return connectionRequestSent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? test,
    TResult? Function()? connectionRequestAccepted,
    TResult? Function()? connectionRequestRejected,
    TResult? Function()? connectionRequestSent,
    TResult? Function()? connectionRequestReceived,
    TResult? Function()? relationshipUpdated,
  }) {
    return connectionRequestSent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? test,
    TResult Function()? connectionRequestAccepted,
    TResult Function()? connectionRequestRejected,
    TResult Function()? connectionRequestSent,
    TResult Function()? connectionRequestReceived,
    TResult Function()? relationshipUpdated,
    required TResult orElse(),
  }) {
    if (connectionRequestSent != null) {
      return connectionRequestSent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(None value) none,
    required TResult Function(Test value) test,
    required TResult Function(ConnectionRequestAccepted value)
        connectionRequestAccepted,
    required TResult Function(ConnectionRequestRejected value)
        connectionRequestRejected,
    required TResult Function(ConnectionRequestSent value)
        connectionRequestSent,
    required TResult Function(ConnectionRequestReceived value)
        connectionRequestReceived,
    required TResult Function(RelationshipUpdated value) relationshipUpdated,
  }) {
    return connectionRequestSent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(None value)? none,
    TResult? Function(Test value)? test,
    TResult? Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult? Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult? Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult? Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult? Function(RelationshipUpdated value)? relationshipUpdated,
  }) {
    return connectionRequestSent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(None value)? none,
    TResult Function(Test value)? test,
    TResult Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult Function(RelationshipUpdated value)? relationshipUpdated,
    required TResult orElse(),
  }) {
    if (connectionRequestSent != null) {
      return connectionRequestSent(this);
    }
    return orElse();
  }
}

abstract class ConnectionRequestSent implements NotificationAction {
  const factory ConnectionRequestSent() = _$ConnectionRequestSent;
}

/// @nodoc
abstract class _$$ConnectionRequestReceivedCopyWith<$Res> {
  factory _$$ConnectionRequestReceivedCopyWith(
          _$ConnectionRequestReceived value,
          $Res Function(_$ConnectionRequestReceived) then) =
      __$$ConnectionRequestReceivedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConnectionRequestReceivedCopyWithImpl<$Res>
    extends _$NotificationActionCopyWithImpl<$Res, _$ConnectionRequestReceived>
    implements _$$ConnectionRequestReceivedCopyWith<$Res> {
  __$$ConnectionRequestReceivedCopyWithImpl(_$ConnectionRequestReceived _value,
      $Res Function(_$ConnectionRequestReceived) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConnectionRequestReceived implements ConnectionRequestReceived {
  const _$ConnectionRequestReceived();

  @override
  String toString() {
    return 'NotificationAction.connectionRequestReceived()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConnectionRequestReceived);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() test,
    required TResult Function() connectionRequestAccepted,
    required TResult Function() connectionRequestRejected,
    required TResult Function() connectionRequestSent,
    required TResult Function() connectionRequestReceived,
    required TResult Function() relationshipUpdated,
  }) {
    return connectionRequestReceived();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? test,
    TResult? Function()? connectionRequestAccepted,
    TResult? Function()? connectionRequestRejected,
    TResult? Function()? connectionRequestSent,
    TResult? Function()? connectionRequestReceived,
    TResult? Function()? relationshipUpdated,
  }) {
    return connectionRequestReceived?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? test,
    TResult Function()? connectionRequestAccepted,
    TResult Function()? connectionRequestRejected,
    TResult Function()? connectionRequestSent,
    TResult Function()? connectionRequestReceived,
    TResult Function()? relationshipUpdated,
    required TResult orElse(),
  }) {
    if (connectionRequestReceived != null) {
      return connectionRequestReceived();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(None value) none,
    required TResult Function(Test value) test,
    required TResult Function(ConnectionRequestAccepted value)
        connectionRequestAccepted,
    required TResult Function(ConnectionRequestRejected value)
        connectionRequestRejected,
    required TResult Function(ConnectionRequestSent value)
        connectionRequestSent,
    required TResult Function(ConnectionRequestReceived value)
        connectionRequestReceived,
    required TResult Function(RelationshipUpdated value) relationshipUpdated,
  }) {
    return connectionRequestReceived(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(None value)? none,
    TResult? Function(Test value)? test,
    TResult? Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult? Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult? Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult? Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult? Function(RelationshipUpdated value)? relationshipUpdated,
  }) {
    return connectionRequestReceived?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(None value)? none,
    TResult Function(Test value)? test,
    TResult Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult Function(RelationshipUpdated value)? relationshipUpdated,
    required TResult orElse(),
  }) {
    if (connectionRequestReceived != null) {
      return connectionRequestReceived(this);
    }
    return orElse();
  }
}

abstract class ConnectionRequestReceived implements NotificationAction {
  const factory ConnectionRequestReceived() = _$ConnectionRequestReceived;
}

/// @nodoc
abstract class _$$RelationshipUpdatedCopyWith<$Res> {
  factory _$$RelationshipUpdatedCopyWith(_$RelationshipUpdated value,
          $Res Function(_$RelationshipUpdated) then) =
      __$$RelationshipUpdatedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RelationshipUpdatedCopyWithImpl<$Res>
    extends _$NotificationActionCopyWithImpl<$Res, _$RelationshipUpdated>
    implements _$$RelationshipUpdatedCopyWith<$Res> {
  __$$RelationshipUpdatedCopyWithImpl(
      _$RelationshipUpdated _value, $Res Function(_$RelationshipUpdated) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RelationshipUpdated implements RelationshipUpdated {
  const _$RelationshipUpdated();

  @override
  String toString() {
    return 'NotificationAction.relationshipUpdated()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RelationshipUpdated);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() test,
    required TResult Function() connectionRequestAccepted,
    required TResult Function() connectionRequestRejected,
    required TResult Function() connectionRequestSent,
    required TResult Function() connectionRequestReceived,
    required TResult Function() relationshipUpdated,
  }) {
    return relationshipUpdated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? test,
    TResult? Function()? connectionRequestAccepted,
    TResult? Function()? connectionRequestRejected,
    TResult? Function()? connectionRequestSent,
    TResult? Function()? connectionRequestReceived,
    TResult? Function()? relationshipUpdated,
  }) {
    return relationshipUpdated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? test,
    TResult Function()? connectionRequestAccepted,
    TResult Function()? connectionRequestRejected,
    TResult Function()? connectionRequestSent,
    TResult Function()? connectionRequestReceived,
    TResult Function()? relationshipUpdated,
    required TResult orElse(),
  }) {
    if (relationshipUpdated != null) {
      return relationshipUpdated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(None value) none,
    required TResult Function(Test value) test,
    required TResult Function(ConnectionRequestAccepted value)
        connectionRequestAccepted,
    required TResult Function(ConnectionRequestRejected value)
        connectionRequestRejected,
    required TResult Function(ConnectionRequestSent value)
        connectionRequestSent,
    required TResult Function(ConnectionRequestReceived value)
        connectionRequestReceived,
    required TResult Function(RelationshipUpdated value) relationshipUpdated,
  }) {
    return relationshipUpdated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(None value)? none,
    TResult? Function(Test value)? test,
    TResult? Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult? Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult? Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult? Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult? Function(RelationshipUpdated value)? relationshipUpdated,
  }) {
    return relationshipUpdated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(None value)? none,
    TResult Function(Test value)? test,
    TResult Function(ConnectionRequestAccepted value)?
        connectionRequestAccepted,
    TResult Function(ConnectionRequestRejected value)?
        connectionRequestRejected,
    TResult Function(ConnectionRequestSent value)? connectionRequestSent,
    TResult Function(ConnectionRequestReceived value)?
        connectionRequestReceived,
    TResult Function(RelationshipUpdated value)? relationshipUpdated,
    required TResult orElse(),
  }) {
    if (relationshipUpdated != null) {
      return relationshipUpdated(this);
    }
    return orElse();
  }
}

abstract class RelationshipUpdated implements NotificationAction {
  const factory RelationshipUpdated() = _$RelationshipUpdated;
}
